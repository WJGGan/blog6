---
weight: 5
title: "DAY1:计算机系统概述+内存管理"
date: 2023-11-21T02:48:04+08:00
lastmod: 2023-11-21T02:48:04+08:00
draft: false
author: "wjg"
authorLink: "https://dillonzq.com"
description: "408三轮归纳"
tags: ["408"]
categories: ["408"]
images: []
resources:
- name: "featured-image"
  src: "featured-image.jpg"
enableEmoji: true
toc:
  auto: false
twemoji: false
lightgallery: true
---

408三轮归纳DAY1
<!--more-->
- os和计组中均有涉及
⭐冯诺依曼
- 冯诺依曼结构：存储程序，程序控制，5大组成部件，以*运算器为中心*，指令和数据形式上无差别的存储在存储器中，根据指令执行的不同阶段区分指令还是数据，数据由指令中的地址码给出，*无法干预*

- 操作系统的发展历程
	- 手工
	- 批处理
		- 单道
		- 冯诺依曼无法干预联想到os多道批处理系统中自动执行，*无法人机交互*，宏观并行微观串行，由于无法人机交互衍生出分时操作系统
			- 考点：中断技术使IO与CPU并行工作👍| 但是与单道相比系统开销大（频繁切换）
	- 分时操作系统：将运行时间分为*时间片*，支持多道程序涉设计的系统，支持多个用户，交互（人机对话），多用户彼此独立的操作，响应及时
	- 实时os：完成紧急任务，规定时间内完成；软实时和硬实时
	- 网络os和分布式
	- 个人计算机os

- 存储器
	- CPU能够直接访问的只有主存中的数据，辅存中的数据要调入内存才能访问（CPU无法直接访问外存），衍生出之后的内存管理
		- [[3 存储系统]]：计算机整体的主存辅存组织规划
		- [[03 内存管理]]：对内存进行合理划分和有效的动态分配&地址转换&内存空间扩充（虚拟存储）&内存共享&存储保护
		- 两者的虚拟存储是一样的，从硬件和os软件的实现层面来描述，是考察的重点，包括地址转换替换算法和缺页等，在选择题和大题中多有考察，通过骚图可以联系起来，已经基本掌握。
- 控制器
	- PC
	- IR
	- CU
# 异常、中断、系统调用
- 各种寄存器也涉及许多考点:是否透明，中断中哪些需要保存等
	- ![[寄存器的透明性.png]]
	- 暂存寄存器：暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员透明
	- 对汇编程序员透明的：MARMDRIR透明不可见，PC可见
	- 中断过程中
		- 中断响应（中断引指令，硬件）：保存断点：*PC PSW*存到栈或特定寄存器中，**异常保存当前PC，中断保存PC+1**
		- 中断处理（软件实现）：保护现场（**用户可见的工作寄存器的内容）和屏蔽字**，通过指令实现，在保存和恢复现场时都要关中断，防止被打断
	- 进程切换中
		- 任何进程的创建撤销和切换以及IO都是利用系统调用进入内核，再通过内核响应处理程序完成，因此可以说：*任何进程都是在os内核支持下运行的（好兄弟*
		- 上下文切换：保存旧上下文到PCB，加载新进程的PCB，上下文包括PC和其它寄存器（整个运行环境;这个过程由os内核完成，故进程切换需要通过系统调用进入内核，再由内核处理程序完成上下文切换
		- 注意区分上下文切换和模式切换：模式切换是内核态和用户态之间，没有改变进程
	- 🤩处理机运行模式（用户态内核态）模式切换
		- os运行在内核态，程序运行在用户态，用户要调用实现核心态的功能时，要通过门🚪来实现，进入门🚪要通过*中断或异常*来实现
		- 中断和异常🚨的区别分类也是一个重点
			- 中断✂️：来自cpu外部的事件（IO ，时钟，*Cache缺失*等
				- 可屏蔽
				- 不可屏蔽
			- 异常❗：来自cpu内部执行指令的事件（非法操作码，溢出，地址越界，*缺页*以及陷入指令）异常不能被屏蔽
				- 故障：非法操作码，除数为0，溢出（浮点数下溢不算异常，缺页故障
				- 自陷：事先安排的，用于*用户态下调用内核*程序，因为在用户态下执行，所以是属于非特权指令
				- 终止：无法继续执行的硬件故障
		- 系统调用（通过中断和异常处理的方式实现
			- 凡是与资源有关的操作（存储分配,IO,传输文件）都必须通过系统调用的方式
			- 故处理系统调用需要在内核态，用特权指令，通过内核程序完成
			- 用户态到核心态通过非特权指令**访管指令**（陷入指令trap），然后通过中断硬件处理完成
			- 核心态到用户态通过特权指令中断返回指令执行（修改PSW）
			- ![[系统调用.jpg]]
		- 用户态到核心态
			- 系统调用 
			- 中断
			- 用户程序中发生错误状态
			- 用户程序企图执行特权指令
			- 2019年真题：可能发生溢出时，可以在后面加一条溢出自陷指令
		- 2012年：中断处理一定会保护但子程序调用不一定会保护的内容是：PSW程序状态字，子程序调用只需保护断点（PC通用寄存器MDRMAR）
		- 2013年：处理外部中断时应由os保存的是
			- 外部中断即与cpu指令无关的中断，通过中断响应和中断服务程序，os负责中断服务程序中保护现场，故需要保存通用寄存器，PC和PSW的值由中断引指令硬件保存
***
- 从源程序到可执行程序
	- 翻译程序：编译程序汇编程序（将高级语言程序变成机器级目标代码的是编译程序）
	- 解释程序：一句一句解释，不会生产
	- 过程：预处理，编译，汇编，链接，装入
		- 编译：将源代码编译成若干目标模块
		- 链接：将目标模块和所需库函数链接在一起，形成完整的装入模块（形成逻辑地址）
			- 静态链接
			- 装入时动态链接
			- 运行时动态链接
		- 装入：由装入程序将模块*装入内存*运行
			- 绝对装入
				- 产生绝对地址，只使用
			- 可重定位
				- 装入时对指令和数据地址的修改过程称为重定位，要求分配全部内存空间且执行过程中无法移动也不能申请新的内存空间
			- 动态运行时装入
				- 地址转换修改等程序真正要执行时才进行，总之就是灵活，动态🙌
# 内存管理
- 虚拟内存管理
	- 会产生*belady现象的只有FIFO*（是分配的页框变多缺页率反而增高
	- 抖动是刚换出的又换入
	- *虚拟内存容量*：为外存和内存之和，最大值受到地址位数的限制，取两者的交集min
	- 工作窗口决定工作集，通过工作集来调整分配的页框数（驻留集）
	- 内存分配策略（3种可变固定/局部全局
	- strategy调入页面的策略
		- 预调页（连续多页
		- 请求调页：一次一页
	- where何处调入（*外存分为文件区和对换区*
		- 足够的对换区：进程有关文件全部调入到对换区，之后全部从对换区调入
		- 缺少足够对换区：不会修改的从文件区调入，会修改的换出到对换区
		- unix：未运行的从文件区，运行过后换出的放在对换区
	- how如何调入
		- 向cpu发送*缺页中断*，与指令有关属于异常
	- Cache的命中缺失替换过程由硬件实现；缺页处理通过软件完成，TLB缺失既可以用软件又可以用
	- 缺页异常需要访问磁盘，开销比较大，虚拟存储器由os和硬件共同实现，对应用程序员透明，对系统程序员不透明。
	- 虚拟存储系统不命中时，不能直接和CPU直接通信，只能由硬盘先调入主存；但Cache缺失是，可以直接和CPU通信。




# 性能指标
- CPI（一条指令几个T
- MIPS（每秒执行多少百万6次方条指令
- MFLOPS（每秒执行多少百万6次方浮点数运算,GFLOPS,TFLOPS
- 字长：指CPU内部用于整数运算的数据通路的宽度，因此等于ALU和通用寄存器的宽度。